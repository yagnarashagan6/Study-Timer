<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Aether Tactics</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&family=Playfair+Display:wght@700&display=swap"
      rel="stylesheet"
    />

    <style>
      /* --- 1. Setup & Variables --- */
      :root {
        --color-bg-start: #0b1020;
        --color-bg-end: #2a2f66;
        --color-accent-coral: #ff6b6b;
        --color-highlight-gold: #ffd27f;
        --color-secondary-teal: #4de1d7;
        --font-ui: "Inter", sans-serif;
        --font-title: "Playfair Display", serif;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: var(--font-ui);
        background: linear-gradient(
          145deg,
          var(--color-bg-start),
          var(--color-bg-end)
        );
        color: #fff;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
        overflow: auto;
        perspective: 1000px;
      }

      /* Iframe compatibility */
      @media (max-height: 600px) {
        body {
          min-height: 600px;
          overflow-y: auto;
        }
      }

      /* When inside iframe */
      body.iframe-mode {
        min-height: 100%;
        height: 100%;
        overflow: auto;
        padding: 20px 10px;
        padding-top: 50px;
        display: flex;
        justify-content: center;
        align-items: center;
      }

      body.iframe-mode #game-board {
        width: clamp(280px, 85vw, 400px);
        height: clamp(280px, 85vw, 400px);
      }

      body.iframe-mode .screen {
        margin-top: 40px;
        padding-top: 20px;
        position: relative;
        top: auto;
        left: auto;
        height: auto;
        min-height: calc(100vh - 100px);
        justify-content: center;
        align-items: center;
      }

      body.iframe-mode #game-screen {
        margin-top: 30px;
        padding-top: 20px;
      }

      body.iframe-mode #start-screen {
        margin-top: 30px;
        padding-top: 20px;
      }

      /* Mobile responsive adjustments for iframe */
      @media (max-width: 768px) {
        body.iframe-mode {
          padding-top: 40px;
          padding: 15px 10px;
        }

        body.iframe-mode .screen {
          margin-top: 30px;
          padding-top: 15px;
          min-height: calc(100vh - 80px);
        }

        body.iframe-mode #game-screen {
          margin-top: 25px;
          gap: 20px;
          padding-top: 15px;
        }

        body.iframe-mode #start-screen {
          margin-top: 25px;
          padding-top: 15px;
        }

        body.iframe-mode #game-board {
          width: clamp(250px, 80vw, 350px);
          height: clamp(250px, 80vw, 350px);
        }
      }

      /* --- 2. Screen Management --- */
      .screen {
        display: none;
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 0;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        padding: 20px;
        animation: fadeIn 0.5s ease-out;
      }

      .screen.active {
        display: flex;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: scale(0.98);
        }
        to {
          opacity: 1;
          transform: scale(1);
        }
      }

      /* --- 3. Start Menu Screen --- */
      #start-screen .title {
        font-family: var(--font-title);
        font-size: clamp(3rem, 10vw, 5rem);
        text-shadow: 0 0 15px rgba(255, 210, 127, 0.4);
        margin-bottom: 40px;
      }

      .menu-buttons {
        display: flex;
        flex-direction: column;
        gap: 15px;
        width: 100%;
        max-width: 300px;
      }

      /* Glassmorphism Button Style */
      .btn {
        font-family: var(--font-ui);
        font-size: 1rem;
        font-weight: 600;
        padding: 15px 20px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 12px;
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        color: #fff;
        cursor: pointer;
        transition: all 0.2s ease;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1),
          inset 0 1px 1px rgba(255, 255, 255, 0.1);
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
      }

      .btn:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: translateY(-2px);
        box-shadow: 0 8px 12px rgba(0, 0, 0, 0.15),
          inset 0 1px 1px rgba(255, 255, 255, 0.1);
      }

      /* --- 4. Game Screen --- */
      #game-screen {
        gap: 30px;
      }

      .game-container {
        position: relative;
      }

      #game-board {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 10px;
        width: clamp(300px, 90vw, 450px);
        height: clamp(300px, 90vw, 450px);
        background: rgba(11, 16, 32, 0.5);
        padding: 10px;
        border-radius: 20px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      }

      .cell {
        background: rgba(255, 255, 255, 0.08);
        border-radius: 15px;
        cursor: pointer;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 4rem;
        transition: background 0.2s;
        position: relative;
        box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2);
      }

      .cell:not(.occupied):hover {
        background: rgba(77, 225, 215, 0.2); /* Teal hover */
      }

      .cell.shake {
        animation: shake 0.4s;
      }

      .cell.hint {
        animation: hint-glow 1.5s infinite;
      }

      @keyframes shake {
        0%,
        100% {
          transform: translateX(0);
        }
        25% {
          transform: translateX(-5px);
        }
        50% {
          transform: translateX(5px);
        }
        75% {
          transform: translateX(-3px);
        }
      }

      @keyframes hint-glow {
        0%,
        100% {
          box-shadow: 0 0 15px rgba(255, 210, 127, 0.4);
        }
        50% {
          box-shadow: 0 0 30px rgba(255, 210, 127, 0.8);
        }
      }

      /* Tokens X and O */
      .cell .token {
        animation: placeToken 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      }

      .token-x {
        width: 70%;
        height: 70%;
        position: relative;
      }
      .token-x::before,
      .token-x::after {
        content: "";
        position: absolute;
        left: 50%;
        top: 50%;
        width: 100%;
        height: 15%;
        background: white;
        border-radius: 10px;
        transform-origin: center;
        box-shadow: 0 0 15px var(--color-highlight-gold);
      }
      .token-x::before {
        transform: translate(-50%, -50%) rotate(45deg);
      }
      .token-x::after {
        transform: translate(-50%, -50%) rotate(-45deg);
      }

      .token-o {
        width: 70%;
        height: 70%;
        border: 15% solid var(--color-secondary-teal);
        border-radius: 50%;
        box-shadow: 0 0 20px var(--color-secondary-teal);
      }

      @keyframes placeToken {
        from {
          transform: scale(0.5);
          opacity: 0;
        }
        to {
          transform: scale(1);
          opacity: 1;
        }
      }

      /* Winning Line */
      #winning-line {
        position: absolute;
        height: 8px;
        background: linear-gradient(
          90deg,
          transparent,
          var(--color-highlight-gold),
          transparent
        );
        border-radius: 4px;
        transform-origin: left;
        display: none;
        box-shadow: 0 0 20px var(--color-highlight-gold);
      }

      /* HUD */
      .hud {
        text-align: center;
        width: 100%;
        max-width: 450px;
      }
      #status-display {
        font-size: 1.5rem;
        min-height: 2.2rem;
        margin-bottom: 20px;
        font-weight: 600;
      }
      .game-buttons {
        display: flex;
        gap: 10px;
        justify-content: center;
      }
      .game-buttons .btn {
        padding: 10px 20px;
        font-size: 0.9rem;
      }
      .game-buttons .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      /* --- 5. Result Modal --- */
      #result-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(5px);
        z-index: 100;
        display: none; /* Initially hidden */
        justify-content: center;
        align-items: center;
        animation: fadeIn 0.3s;
      }

      .modal-content {
        background: linear-gradient(
          145deg,
          var(--color-bg-end),
          var(--color-bg-start)
        );
        padding: 40px;
        border-radius: 20px;
        text-align: center;
        width: 90%;
        max-width: 400px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      #result-message {
        font-family: var(--font-title);
        font-size: 2.5rem;
        margin-bottom: 30px;
      }

      .modal-buttons {
        display: flex;
        justify-content: center;
        gap: 15px;
      }
    </style>
  </head>
  <body>
    <div id="start-screen" class="screen active">
      <h1 class="title">Aether Tactics</h1>
      <div class="menu-buttons">
        <button class="btn" data-mode="pvp">Player vs Player</button>
        <button class="btn" data-mode="ai_easy">Player vs AI (Easy)</button>
        <button class="btn" data-mode="ai_expert">Player vs AI (Expert)</button>
      </div>
    </div>

    <div id="game-screen" class="screen">
      <div class="hud">
        <div id="status-display">Player X's Turn</div>
        <div class="game-buttons">
          <button id="undo-btn" class="btn" disabled>Undo</button>
          <button id="hint-btn" class="btn" disabled>Hint</button>
          <button id="menu-btn" class="btn">Menu</button>
        </div>
      </div>
      <div class="game-container">
        <div id="game-board"></div>
        <div id="winning-line"></div>
      </div>
    </div>

    <div id="result-modal">
      <div class="modal-content">
        <h2 id="result-message"></h2>
        <div class="modal-buttons">
          <button id="replay-btn" class="btn">Replay</button>
          <button id="modal-menu-btn" class="btn">Main Menu</button>
        </div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.2/dist/confetti.browser.min.js"></script>
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        // Detect if running in iframe and adjust styling
        if (window.self !== window.top) {
          document.body.classList.add("iframe-mode");
        }

        // --- 1. DOM Elements & State Variables ---
        const startScreen = document.getElementById("start-screen");
        const gameScreen = document.getElementById("game-screen");
        const boardElement = document.getElementById("game-board");
        const statusDisplay = document.getElementById("status-display");
        const resultModal = document.getElementById("result-modal");
        const resultMessage = document.getElementById("result-message");
        const winningLine = document.getElementById("winning-line");

        const undoBtn = document.getElementById("undo-btn");
        const hintBtn = document.getElementById("hint-btn");

        const PLAYER_X = "X";
        const PLAYER_O = "O";
        const AI_PLAYER = PLAYER_O;

        let board = Array(9).fill(null);
        let currentPlayer = PLAYER_X;
        let gameMode = "pvp"; // pvp, ai_easy, ai_expert
        let isGameOver = false;
        let moveHistory = [];

        // Placeholder for sounds
        const sounds = {
          place: new Audio(
            "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA"
          ), // short click
          win: new Audio(
            "data:audio/wav;base64,UklGRiIGAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAAAAAAsA/v/V/9f/wf/K/8X/w//C/8L/w//D/8T/yv/Q/9b/3P/g/+T/7f/y//f/AgAEAAwADgAOAAoACQAHAAUAAwABAAAAAP//9f/s/9//AgABAAMABQAHAAgACgAOAA4ADAAAAAD//w=="
          ), // simple win chime
          tie: new Audio(
            "data:audio/wav;base64,UklGRiIGAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAAAAAAsA/v/V/9f/wf/K/8X/w//C/8L/w//D/8T/yv/Q/9b/3P/g/+T/7f/y//f/AgAEAAwADgAOAAoACQAHAAUAAwABAAAAAP//9f/s/9//AgABAAMABQAHAAgACgAOAA4ADAAAAAD//w=="
          ),
          invalid: new Audio(
            "data:audio/wav;base64,UklGRiIAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhBgAAAAMA/v8="
          ),
          click: new Audio(
            "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA"
          ),
        };

        // --- 2. Game Setup & Transitions ---
        function showScreen(screenId) {
          document
            .querySelectorAll(".screen")
            .forEach((s) => s.classList.remove("active"));
          document.getElementById(screenId).classList.add("active");
        }

        function startGame(mode) {
          gameMode = mode;
          board.fill(null);
          currentPlayer = PLAYER_X;
          isGameOver = false;
          moveHistory = [];
          boardElement.innerHTML = "";
          winningLine.style.display = "none";

          for (let i = 0; i < 9; i++) {
            const cell = document.createElement("div");
            cell.classList.add("cell");
            cell.dataset.index = i;
            cell.addEventListener("click", handleCellClick);
            boardElement.appendChild(cell);
          }

          updateUI();
          showScreen("game-screen");
          sounds.click.play();
        }

        // --- 3. Core Gameplay Logic ---
        function handleCellClick(e) {
          if (isGameOver) return;
          const index = parseInt(e.target.dataset.index);

          if (
            board[index] ||
            (gameMode !== "pvp" && currentPlayer === AI_PLAYER)
          ) {
            if (!board[index]) return;
            e.target.classList.add("shake");
            sounds.invalid.play();
            setTimeout(() => e.target.classList.remove("shake"), 400);
            return;
          }

          makeMove(index, currentPlayer);

          if (checkWin(currentPlayer)) {
            endGame(false);
          } else if (board.every((cell) => cell)) {
            endGame(true);
          } else {
            switchPlayer();
          }
        }

        function makeMove(index, player) {
          board[index] = player;
          moveHistory.push(index);
          updateUI();
          sounds.place.play();
        }

        function switchPlayer() {
          currentPlayer = currentPlayer === PLAYER_X ? PLAYER_O : PLAYER_X;
          updateUI();

          if (
            gameMode !== "pvp" &&
            currentPlayer === AI_PLAYER &&
            !isGameOver
          ) {
            triggerAIMove();
          }
        }

        const winConditions = [
          [0, 1, 2],
          [3, 4, 5],
          [6, 7, 8],
          [0, 3, 6],
          [1, 4, 7],
          [2, 5, 8],
          [0, 4, 8],
          [2, 4, 6],
        ];

        function checkWin(player) {
          return winConditions.find((combination) => {
            return combination.every((index) => board[index] === player);
          });
        }

        function endGame(isTie) {
          isGameOver = true;
          if (isTie) {
            statusDisplay.textContent = "It's a Tie!";
            sounds.tie.play();
            setTimeout(() => showResultModal("It's a Tie!"), 1000);
          } else {
            const winningCombination = checkWin(currentPlayer);
            statusDisplay.textContent = `${currentPlayer} Wins!`;
            showWinningLine(winningCombination);
            sounds.win.play();
            confetti({ particleCount: 100, spread: 70, origin: { y: 0.6 } });
            setTimeout(() => showResultModal(`${currentPlayer} Wins!`), 1500);
          }
          updateUI();
        }

        // --- 4. AI Logic ---
        function triggerAIMove() {
          statusDisplay.textContent = "AI is thinking...";
          const delay = gameMode === "ai_expert" ? 400 : 200;

          setTimeout(() => {
            let move;
            if (gameMode === "ai_easy") {
              move = getEasyAIMove();
            } else {
              // ai_expert
              move = getExpertAIMove();
            }
            if (move !== null) {
              makeMove(move, AI_PLAYER);
              if (checkWin(AI_PLAYER)) {
                endGame(false);
              } else if (board.every((cell) => cell)) {
                endGame(true);
              } else {
                switchPlayer();
              }
            }
          }, delay);
        }

        // Modified Easy AI
        function getEasyAIMove() {
          const emptyCells = board
            .map((val, idx) => (val === null ? idx : null))
            .filter((val) => val !== null);

          // Step 1: Very early game - act playful
          if (moveHistory.length < 2) {
            // Pick a random move, even if it's silly
            return emptyCells[Math.floor(Math.random() * emptyCells.length)];
          }

          // Step 2: Mid game - sometimes playful, sometimes smart
          if (Math.random() < 0.5) {
            // 50% chance: use minimax (smart)
            return minimax(board, AI_PLAYER).index;
          } else {
            // 50% chance: pick a random move
            return emptyCells[Math.floor(Math.random() * emptyCells.length)];
          }
        }

        // Modified Expert AI
        function getExpertAIMove() {
          // 90% chance: play perfectly (minimax)
          // 10% chance: make a small mistake (random move)
          if (Math.random() < 0.9) {
            return minimax(board, AI_PLAYER).index;
          } else {
            const emptyCells = board
              .map((val, idx) => (val === null ? idx : null))
              .filter((val) => val !== null);
            return emptyCells[Math.floor(Math.random() * emptyCells.length)];
          }
        }

        function minimax(newBoard, player) {
          const availSpots = newBoard
            .map((val, idx) => (val === null ? idx : null))
            .filter((val) => val !== null);

          if (checkWinOnBoard(newBoard, PLAYER_X)) return { score: -10 };
          if (checkWinOnBoard(newBoard, AI_PLAYER)) return { score: 10 };
          if (availSpots.length === 0) return { score: 0 };

          const moves = [];
          for (let i = 0; i < availSpots.length; i++) {
            const move = {};
            move.index = availSpots[i];
            newBoard[availSpots[i]] = player;

            if (player === AI_PLAYER) {
              const result = minimax(newBoard, PLAYER_X);
              move.score = result.score;
            } else {
              const result = minimax(newBoard, AI_PLAYER);
              move.score = result.score;
            }
            newBoard[availSpots[i]] = null;
            moves.push(move);
          }

          let bestMove;
          if (player === AI_PLAYER) {
            let bestScore = -10000;
            for (let i = 0; i < moves.length; i++) {
              if (moves[i].score > bestScore) {
                bestScore = moves[i].score;
                bestMove = i;
              }
            }
          } else {
            let bestScore = 10000;
            for (let i = 0; i < moves.length; i++) {
              if (moves[i].score < bestScore) {
                bestScore = moves[i].score;
                bestMove = i;
              }
            }
          }
          return moves[bestMove];
        }

        function checkWinOnBoard(boardToCheck, player) {
          return winConditions.some((combination) => {
            return combination.every((index) => boardToCheck[index] === player);
          });
        }

        // --- 5. UI & Animations ---
        function updateUI() {
          boardElement.querySelectorAll(".cell").forEach((cell, index) => {
            cell.innerHTML = ""; // Clear previous content
            cell.classList.remove("occupied");
            if (board[index]) {
              const token = document.createElement("div");
              token.classList.add(
                "token",
                board[index] === PLAYER_X ? "token-x" : "token-o"
              );
              cell.appendChild(token);
              cell.classList.add("occupied");
            }
          });

          if (!isGameOver) {
            statusDisplay.textContent = `${currentPlayer}'s Turn`;
          }

          undoBtn.disabled = isGameOver || moveHistory.length === 0;
          hintBtn.disabled =
            isGameOver || gameMode === "pvp" || currentPlayer !== PLAYER_X;
        }

        function showWinningLine(combination) {
          const [a, b, c] = combination;
          const cellA = boardElement.children[a];
          const cellC = boardElement.children[c];

          const boardRect = boardElement.getBoundingClientRect();
          const cellARect = cellA.getBoundingClientRect();
          const cellCRect = cellC.getBoundingClientRect();

          const startX = cellARect.left + cellARect.width / 2 - boardRect.left;
          const startY = cellARect.top + cellARect.height / 2 - boardRect.top;
          const endX = cellCRect.left + cellCRect.width / 2 - boardRect.left;
          const endY = cellCRect.top + cellCRect.height / 2 - boardRect.top;

          const angle =
            (Math.atan2(endY - startY, endX - startX) * 180) / Math.PI;
          const length = Math.sqrt(
            Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2)
          );

          winningLine.style.width = `${length}px`;
          winningLine.style.top = `${startY}px`;
          winningLine.style.left = `${startX}px`;
          winningLine.style.transform = `rotate(${angle}deg)`;
          winningLine.style.display = "block";
          winningLine.style.animation = "stretchLine 0.4s ease-out";
        }

        function showResultModal(message) {
          resultMessage.textContent = message;
          resultModal.style.display = "flex";
        }

        function hideResultModal() {
          resultModal.style.display = "none";
        }

        // --- 6. Event Listeners ---
        document
          .querySelector(".menu-buttons")
          .addEventListener("click", (e) => {
            if (e.target.tagName === "BUTTON") {
              startGame(e.target.dataset.mode);
            }
          });

        document.getElementById("replay-btn").addEventListener("click", () => {
          hideResultModal();
          startGame(gameMode);
          sounds.click.play();
        });

        document
          .getElementById("modal-menu-btn")
          .addEventListener("click", () => {
            hideResultModal();
            showScreen("start-screen");
            sounds.click.play();
          });

        document.getElementById("menu-btn").addEventListener("click", () => {
          showScreen("start-screen");
          sounds.click.play();
        });

        undoBtn.addEventListener("click", () => {
          if (isGameOver || moveHistory.length === 0) return;

          const lastMoveIndex = moveHistory.pop();
          board[lastMoveIndex] = null;

          if (gameMode !== "pvp" && moveHistory.length % 2 !== 0) {
            // If it was AI's turn, undo player's move before it too
            const playerMoveIndex = moveHistory.pop();
            board[playerMoveIndex] = null;
          } else if (gameMode === "pvp") {
            // In PvP, just switch the player back
            currentPlayer = currentPlayer === PLAYER_X ? PLAYER_O : PLAYER_X;
          }

          updateUI();
          sounds.click.play();
        });

        hintBtn.addEventListener("click", () => {
          if (isGameOver || gameMode === "pvp" || currentPlayer !== PLAYER_X)
            return;
          const hintMove = minimax(board, PLAYER_X).index; // Find best move for the human player
          if (hintMove !== undefined) {
            const hintCell = boardElement.children[hintMove];
            hintCell.classList.add("hint");
            setTimeout(() => hintCell.classList.remove("hint"), 1500);
          }
        });
      });
    </script>
  </body>
</html>
